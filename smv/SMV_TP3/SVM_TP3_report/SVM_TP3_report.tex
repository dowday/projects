\documentclass[a4paper,11pt,final]{article}
% Pour une impression recto verso, utilisez plutôt ce documentclass :
%\documentclass[a4paper,11pt,twoside,final]{article}

\usepackage[english,francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[sc]{mathpazo}
\usepackage[pdftex]{graphicx}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage[french]{varioref}
\usepackage{epstopdf}
\usepackage{comment}
\usepackage{enumerate}
\usepackage{color}
\usepackage{amsmath}
\usepackage{fancyhdr}
%\pagestyle{fancy}
\usepackage{lastpage}
%\fancyhf{}
\rhead{Analyse et Traitement de l’Information}
\lhead{Oday Darwich}
%\rfoot{Pags\ \thepage \ of \ \pageref{LastPage}}
\rfoot{Page\ \thepage}
\usepackage{listings}
\usepackage{color}


\usepackage{filecontents}
\usepackage{xcolor}
\usepackage{xparse}% to define star variant of macro

 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{yellow},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\begin{filecontents*}{graph.adt}

import "boolean.adt"

Adt graph
	Sorts
		node;
		edge;
		graph;
		
	Generators
		//nodes
		A : node;
		B : node;
		C : node;
		D : node;
		
		//an edge is a pair of nodes
		edge : node, node -> edge;	
		//inductive definition of a graph: it is a set of edges
		empty : graph;
		noedge : edge;
		cons: edge, graph -> graph;

	Operations
		//source of an edge
		source : edge -> node;
		//target of an edge
		target : edge -> node;
		//remove an edge from the graph
		remove : graph, edge -> graph;
		// check if a node is terminal
		isTerminal : graph, node -> bool;
		//check if there is an edge in the graph from a given node in source
		existsEdge : graph, node -> bool;
		//get the first edge in the graph from a given node, what if there are no edge for this node ?
		getEdge : graph, node -> edge; 
		//check if there is a path from a node to another node
		canReach : node, node, graph -> bool;
		//tester si un noeud appartient ˆ un cycle
		existsCycle : node, graph -> bool;
/**/
	Axioms
		//source & target
		source(edge($x, $y)) = $x;
		target(edge($x, $y)) = $y;
		
		//remove
		remove(empty, $e) = empty; //2
		if $e = $e1 then remove(cons($e1,$g), $e) = $g; //3 
		if $e != $e1 then remove(cons($e1,$g),$e) = cons($e1,remove($g,$e));
			
		//isTerminal
		isTerminal(empty, $x) = false;
		if $g != empty & existsEdge($g,$x) = false then isTerminal($g,$x) = true;
		if $g != empty & existsEdge($g,$x) = true then isTerminal($g,$x) = false;

		
		//getEdge
		getEdge(empty, $x) = noedge;
		if source($e) = $x then getEdge(cons($e,$g),$x) = $e;
		if source($e) != $x then getEdge(cons($e,$g),$x) = getEdge($g,$x);
		
		//existsEdge
		existsEdge(empty, $x) = false;
		if $x  = source($e) then existsEdge(cons($e, $g),$x) = true;
		if $x != source($e) then existsEdge(cons($e, $g),$x)  = existsEdge($g,$x); 

		//canReach
		//A node can always be reached from itself
		if $x = $y then canReach($x, $y, $g) = true;
		if $x != $y then canReach($x, $y, empty) = false;
		if $x != $y & $g != empty & existsEdge($g, $x) = false then canReach($x, $y, $g) = false;
		if $x != $y & $g !=empty & existsEdge($g, $x) = true then canReach($x, $y, $g) = or(canReach(target(getEdge($g,$x)), $y, remove($g, getEdge($g, $x))),canReach($x,$y, remove($g, getEdge($g, $x))));

		//existsCycle

		if existsEdge($g, $x) = false  then  existsCycle($x,$g)  = false; // si dans le graphe pas d'edge qui part de $x
		if existsEdge($g, $x) = true  then existsCycle($x,$g) =  or(canReach( target(getEdge($g,$x)), $x, remove($g,getEdge($g,$x))), existsCycle($x, remove($g,getEdge($g,$x))));
		 

	Theorems
		canReach(A, D, cons(edge(A,C), cons(edge(A,B), cons(edge(B,C), cons(edge(D,C), cons(edge(C,A), empty)))))) = false;
		canReach(A, C, cons(edge(A,C), cons(edge(A,B), cons(edge(B,C), cons(edge(D,C), cons(edge(C,A), empty)))))) = true;
		//canReach(A, A, empty) = true;
		existsCycle(A, cons(edge(A,C), cons(edge(A,B), cons(edge(B,C), cons(edge(D,C), cons(edge(C,A), empty)))))) = true;
		existsCycle(C, cons(edge(A,C), cons(edge(A,B), cons(edge(B,C), cons(edge(C,D), cons(edge(C,A), empty)))))) = true;
		existsCycle(D, cons(edge(A,C), cons(edge(A,B), cons(edge(B,C), cons(edge(D,C), cons(edge(C,A), empty)))))) = false;
		existsCycle(A, empty) = false;
		existsCycle(A, cons(edge(A,A), empty)) = true;
	Variables
		x : node;
		y : node;
		e : edge;
		e1 : edge;
		g : graph;
\end{filecontents*}

\begin{filecontents*}{test.adt}

\\
target(edge(A,B))

\\
existsEdge(cons(edge(B,C), cons(edge(D,C), cons(edge(C,A), empty))),C)

\\Test to is Terminal
isTerminal(cons(edge(B,C),C))
isTerminal(cons(edge(B,C), cons(edge(D,C), cons(edge(C,A), empty))),A)
isTerminal(cons(edge(A,C), cons(edge(A,B), cons(edge(B,C), cons(edge(D,C), cons(edge(C,A), empty))))),A)
isTerminal(cons(edge(A,B),empty),B) > if ture
isTerminal(cons(edge(A,B),empty),A) > if false
isTerminal(empty,A)

\\ test de remove : 
remove(cons(edge(D,C), cons(edge(C,A), empty)),edge(C,A))
remove(cons(edge(D,C), cons(edge(C,A), empty)),edge(C,A))
					cons(edge(D, C), empty)
					
//test of Get edge

getEdge(cons(edge(D,C), cons(edge(C,A), empty)),D)  --> for the first case|| the edge of D
getEdge(cons(edge(D,C), cons(edge(C,A), empty)),D)  --> the second case || there are no edge D
getEdge(cons(edge(D,C), cons(edge(C,A), empty)),C)  --> if the a node is not the first go recusivly

\\ existsCycle
existsCycle(D,cons(edge(D,C), cons(edge(C,A), empty))
\end{filecontents*}


\lstdefinestyle{MyListStyle} {
    numbers=left,
    language=Java,
    backgroundcolor={\color{yellow}},
    breaklines=true
    }
    \include{packages}
    \include{pagesconfigurations}
    \include{codegraph.adt}
    \include{codeboolean.adt}
\begin{document}

\include{title}
\section{Introduction}

\subsection{Definition of Abstract Data Type (ADT):}

\paragraph{Abstract Data Type}is a mathematical model for data, known as \textbf{ADT}, where a data type is defined by its behavior (semantics).\\
To understand ADT, lets take two steps back, If we take off \textbf{Abstract} and Data from ADT, now we have type, and a \textbf{type} would be \textbf{defined} as a \textbf{collection} of \textbf{type values}, e.g., integer type, 0, 1, 2 etc.\\
If we add the \textbf{Data} back in we would \textbf{define data type} as  a \textbf{type} and the \textbf{set of operations} that will \textbf{manipulate the type}, e.g., addition, subtraction, and multiplication are operations that can be performed on the integer data type.\\
So, we can define an \textbf{abstract data type} (\textbf{ADT}) as a \textbf{data type}, that \textbf{is a type and the set of operations\label{operationsapp} \ref{operations} that will manipulate the type}, e.g., for the integer data type, the operations might be delete an integer, add an integer, print an integer, and check to see if a certain integer exists.\paragraph{In this TP,}we will create ADT to define oriented graphs, i.e., directed graph is an ordered pair G = (V, A) with
\begin{itemize}
\item[$\bullet$] V a set whose elements are called vertices, nodes\label{node}, or points;
\item[$\bullet$] A a set of ordered pairs of vertices, called arrows, directed edges (sometimes simply edges with the corresponding set named E instead of A), directed arcs, or directed lines.
\end{itemize} To do this, we will use an eclipse plugin called \textbf{ALPiNA}, i.e., \textbf{Al}gebraic \textbf{P}etri \textbf{N}ets \textbf{A}nalyzer and is a model checker for Algebraic Petri Nets. And with the rewriting tool in ALPiNA we will check with our solution that all the theorems defined in \textcolor{colour3}{graph.adt} are validated.
So, we will construct \textcolor{colour3}{graph.adt} file by replacing the *** with the adequate expressions.

\subsection{File structure :}
In this section i am describing each part enumerated in \textcolor{blue}{blue from 1 two 5 on left side}, and each part i explain the code line by line (you see on the left the gray background the number of the code line on the \textbf{graph.adt} file).\\
And in the TP after completing my axioms i did tests to verify it (you can find code \ref{App:code} lines and tests \ref{App:test} on the annex).
\begin{enumerate}[label=\color{blue}\theenumi]
\item \textbf{The head} of the  \textbf{graph.adt} \textit{.adt} file contains all file that we may use to construct our axioms.\\
In this TP we need to import {\textcolor{colour3}{boolean.adt}}.\label{importboolean}
\noindent
\lstinputlisting[style=MyListStyle1, linerange={2-2},firstnumber=2,]{codegraph.adt} in which we have added  the axioms to define the behavior of the operators \textbf{not} and \textbf{and} as we have seen in the exercices. I also added the axioms of the operator \textbf{or} which i want to use it after in axioms like $canReach(,,)$ and $existsCycle(,)$.
\lstinputlisting[style=MyListStyle1, linerange={19-21},firstnumber=18,]{codeboolean.adt}
\bigskip
\noindent And also in the \textbf{Head} we write the name of the \textit {.adt} file that we are workin on.
\lstinputlisting[style=MyListStyle1, linerange={4-4},firstnumber=4,]{codegraph.adt}
%\bigskip

\item \textcolor{colour0}{Sorts} \label{sort}: an ADT is a set of values, and the Sorts are names of Abstract data type.
\newpage
\item \textcolor{colour0}{Generators}\label{generator}: Define Functions and The base cases.\\
As we see on the theorems in the bottom of the file graph.adt we have 4 nodes, so we complete defining the 4 nodes A, B, C, D by replacing the *** as you see below.
\lstinputlisting[style=MyListStyle1, linerange={10-15},firstnumber=10,]{codegraph.adt}
% %<

% %>edge methode:
\bigskip\noindent
\lstinputlisting[style=MyListStyle1, linerange={18-18},firstnumber=18,]{codegraph.adt}
The method edge is to create an edge from the pairs of nodes.\\
% %>empty
\bigskip\noindent
\lstinputlisting[style=MyListStyle1, linerange={20-20},firstnumber=20,]{codegraph.adt}
empty is type of graph and we define the graph inductivly (as \textbf{AT)}\\
% %> noedge
\bigskip\noindent
\lstinputlisting[style=MyListStyle1, linerange={21-21},firstnumber=21,]{codegraph.adt}
\label{noedge}I want to use this on the axiom getEdge \ref{axiomgetedge}\\

% %> cons
\bigskip\noindent
\lstinputlisting[style=MyListStyle1, linerange={22-22},firstnumber=22,]{codegraph.adt}
We want to define inductivly a graph so the result of cons should be graph.\\
and as we on the \textbf{(L49)} \ref{cons} $cons($\$e1$,\$g)$ take $\$e1$, so edge as first parameter and graph $\$g$ as second parameter.

\bigskip\noindent
\include{operations}
\bigskip\noindent
\include{axioms}
\item \textcolor{colour0}{Theorems}\label{theorems}: A theorem is a statement that can be demonstrated to be true by accepted mathematical operations and arguments.

\item \textcolor{colour0}{Variables}\label{variables}: It's a generic element of sorts.
\end{enumerate}

\section{Conclusion}
I find an interesting thing in ADT that we can do the recursivity and it's so efficient especially in computer science.
We can also construct different axioms independently from each other, But i see that it's difficult to construct an axiom  too independent from another axiom which treat another case (like if i change the first axiom of exist cycle, in a second case for this axioms most of time they are dependent and it's too difficult to separate) because if i introduce an axioms in another one and i want to change one of them that may cause a fault result which is not good and also we cannot know if we don't know what result we are attending after doing the tests.\\
After this TP i can say that i understand very well how ADT works, and i also learn to do not give up in a TP!.
\newpage
\appendix
\section{Code} \label{App:code}
\lstinputlisting[style=MyListStyle1, linerange={},firstnumber=1,]{filecode.adt}
\section{Some Test} \label{App:test}
\lstinputlisting[style=MyListStyle, linerange={},firstnumber=1,]{test.adt}


%%Showing lines 1,3,7,12 (note that Line 7 is blank) with starred version between lines 1 and 3 to supress the space and the space before line 12 set to 50\% of the \verb|\baselineskip|:

%%\NewDocumentCommand{\ShowListingForLineNumber}{s O{1.0} m m}{
%%    \IfBooleanTF{#1}{\vspace{-#2\baselineskip}}{}
%%    \lstinputlisting[
%%            style=MyListStyle1,
%%            linerange={#3-#3},
%%            firstnumber=#3,
%%            ]{#4}
%%}%
%%
%%\ShowListingForLineNumber{3}{graph.adt}% supress space before
%%\ShowListingForLineNumber{7}{graph.adt}% supress 50% of the space before
%%\ShowListingForLineNumber{12}{graph.adt}
%%\lstinputlisting[style=MyListStyle1, linerange={42-42},firstnumber=42]{graph.adt}

\end{document}